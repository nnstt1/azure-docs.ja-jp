---
title: Azure Service Fabric のステートフル サービスの単体テスト
description: Service Fabric のステートフル サービスの単体テストの概念と実践について説明します。
ms.topic: conceptual
ms.date: 09/04/2018
ms.openlocfilehash: e8247d9c71f73f00bd9b8235778f7256af72ed27
ms.sourcegitcommit: 91915e57ee9b42a76659f6ab78916ccba517e0a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/15/2021
ms.locfileid: "130042619"
---
# <a name="unit-testing-stateful-services-in-service-fabric"></a>Service Fabric のステートフル サービスの単体テスト

この記事では、Service Fabric のステートフル サービスの単体テストの概念と実践について説明します。 複数のさまざまなコンテキストでアプリケーション コードがアクティブとして稼働するため、Service Fabric 内での単体テストには固有の考慮事項があります。 この記事では、アプリケーション コードに想定されるさまざまな実行コンテキストをすべてテストでカバーするために用いられる各種の実践について取り上げます。

## <a name="unit-testing-and-mocking"></a>単体テストとモック作成
この記事の文脈での単体テストとは、テスト ランナー (MSTest、NUnit など) のコンテキスト内で実行できる自動化されたテストです。 この記事の単体テストでは、リモート リソース (データベース、RESTful など) に対する操作を実行しません。 これらのリモート リソースはモック作成する必要があります。 この記事の文脈では、モック作成によって、リモートリソースに対する戻り値の擬似的な再現、記録、制御を行います。

### <a name="service-fabric-considerations"></a>Service Fabric の考慮事項
Service Fabric のステートフル サービスに対する単体テストには、いくつかの考慮事項があります。 まず、サービス コードは、複数のノードで、かつさまざまなロールの下で実行されます。 単体テストですべてのケースを網羅するためには、それぞれのロールの下でコードを評価しなければなりません。 ロールの種類としては、Primary、Active Secondary、Idle Secondary、Unknown があります。 "None" というロールもありますが、このロールは、Service Fabric によって無効または NULL サービスと見なされるので、通常は特にテストでカバーする必要はありません。 次に、各ノードのロールはそのときどきで変化します。 すべてのケースを網羅するためには、ロールを変化させながらコードの実行パスをテストする必要があります。

## <a name="why-unit-test-stateful-services"></a>ステートフル サービスに対して単体テストを実施する理由 
ステートフル サービスの単体テストにより、従来のアプリケーションまたはドメイン固有の単体テストでは必ずしも検出されない一般的な誤りを発見しやすくなります。 たとえば、ステートフル サービスの状態がメモリ内に格納されている場合、このタイプのテストであれば、このメモリ内の状態が各レプリカ間で同期されているかどうかを確認できます。 また、Service Fabric オーケストレーションによって渡されたキャンセル トークンに対して、ステートフル サービスが適切に応答しているかどうかも、このタイプのテストなら確認できます。 キャンセルがトリガーされたとき、長時間実行される処理や非同期処理があれば、サービスはそれらを停止する必要があります。  

## <a name="common-practices"></a>一般的な実践

次のセクションでは、ステートフル サービスの単体テストに関する最も一般的な実践について推奨事項を取り上げます。 また、Service Fabric のオーケストレーションや状態管理に近づけるためにモック作成レイヤーに必要な要素についての推奨事項も紹介します。 [ServiceFabric.Mocks](https://www.nuget.org/packages/ServiceFabric.Mocks/) (3.3.0 以降) はそのようなライブラリの 1 つであり、モック作成するために推奨され、かつ以下で取り上げる各種の実践に則した機能を備えています。

### <a name="arrangement"></a>準備

#### <a name="use-multiple-service-instances"></a>複数のサービス インスタンスを使用する
単体テストは、ステートフル サービスのインスタンスを複数実行する必要があります。 そうすることで、クラスターで実際に起こる事象がシミュレートされます。クラスターには、サービスを実行する複数のレプリカが、Service Fabric により複数のノードにまたがってプロビジョニングされるからです。 ただし、これらのインスタンスはそれぞれ異なるコンテキストで実行されます。 テストを実行する際は、そのクラスターに想定されるロール構成で各インスタンスを準備する必要があります。 たとえば、サービスに想定されるターゲット レプリカのサイズが 3 である場合、Service Fabric によって 3 つのレプリカが別々のノードにプロビジョニングされます。 そのうちの 1 つがプライマリになり、他の 2 つはアクティブ セカンダリになります。

ほとんどの場合、これらのロールごとにサービスの実行パスが若干異なります。 たとえば Active Secondary からの要求を受け付けるべきではない場合、サービスではこのようなケースに対するチェックを行い、要求がセカンダリに対して試みられたことを示す、情報提供を目的とした例外をスローする必要があります。 複数のインスタンスがあれば、この状況をテストすることができます。

また、インスタンスが複数あれば、その各インスタンスのロールをテストで切り替え、ロールが変わっても応答に一貫性があることを確認することが可能です。

#### <a name="mock-the-state-manager"></a>状態マネージャーをモック作成する
状態マネージャーはリモート リソースとして扱う必要があるため、モック作成する必要があります。 状態マネージャーをモック作成するときは、状態マネージャーに保存された情報の追跡用に、その情報を読み取って確認できるよう、基になるメモリ内の記憶域が必要です。 そのための最も単純な方法は、Reliable Collections の型ごとにモック インスタンスを作成することです。 そのモック内で、対応するコレクションに対して実行される操作にちょうど合うデータ型を使用します。 以下、いくつかの推奨されるデータ型をリライアブル コレクションごとに示します。

- IReliableDictionary<TKey, TValue> -> System.Collections.Concurrent.ConcurrentDictionary<TKey, TValue>
- IReliableQueue\<T> -> System.Collections.Generic.Queue\<T>
- IReliableConcurrentQueue\<T> -> System.Collections.Concurrent.ConcurrentQueue\<T>

#### <a name="many-state-manager-instances-single-storage"></a>状態マネージャーのインスタンスは多数、ストレージは単一
前述のように、状態マネージャーとリライアブル コレクションはリモート リソースとして扱う必要があります。 したがって、単体テスト内では、これらのリソースをモック作成することになります。 しかしステートフル サービスのインスタンスを複数実行しているときに、そのさまざまなインスタンス全体で、モック作成された各状態マネージャーの同期状態を維持することは簡単ではありません。 ステートフル サービスがクラスター上で実行されているときは、Service Fabric によって、各セカンダリ レプリカの状態マネージャーとプライマリ レプリカの整合性をとるための処理が行われます。 したがって、ロールの変更をシミュレートできるよう、テストにも同じ振る舞いを持たせなければなりません。

この同期を実現する簡単な方法があります。それは、各リライアブル コレクションに書き込まれたデータを格納する基になるオブジェクトにシングルトン パターンを使用することです。 たとえば、ステートフル サービスで `IReliableDictionary<string, string>` が使用されているとしましょう。 モックの状態マネージャーは、`IReliableDictionary<string, string>` のモックを返す必要があります。 そのモックは、書き込まれたキー/値のペアを `ConcurrentDictionary<string, string>` を使って追跡することができます。 この `ConcurrentDictionary<string, string>` は、サービスに渡された状態マネージャーのすべてのインスタンスで使用されるシングルトンとする必要があります。

#### <a name="keep-track-of-cancellation-tokens"></a>キャンセル トークンを追跡する
キャンセル トークンは、ステートフル サービスの重要な要素でありながら、見過ごされることの多い要素でもあります。 Service Fabric がステートフル サービスのプライマリ レプリカを起動するときに、キャンセル トークンが与えられます。 削除されたり別のロールに降格されたときに、サービスに対して通知することが、このキャンセル トークンの目的です。 ステートフル サービスは、Service Fabric がロール変更ワークフローを遂行できるよう、長時間実行される処理や非同期処理を停止する必要があります。

RunAsync、ChangeRoleAsync、OpenAsync、CloseAsync に与えられたキャンセル トークンは、単体テストの実行中、保持されなければなりません。 これらのトークンを保持することによって、テストでサービスのシャットダウンや降格をシミュレートしたり、サービスが適切に応答しているかどうかを確認したりすることができます。

#### <a name="test-end-to-end-with-mocked-remote-resources"></a>モック作成したリモート リソースを使ってエンド ツー エンドでテストする
単体テストは、ステートフル サービスの状態変更を引き起こす可能性のあるアプリケーション コードをできるだけ多く実行する必要があります。 テストは、エンド ツー エンドな性格を帯びたものにすることをお勧めします。 リモート リソースの対話は、存在するモックだけで記録、シミュレート、確認することになります。 これには、状態マネージャーとの対話やリライアブル コレクションとの対話が含まれます。 次のスニペットは、エンド ツー エンドのテストをデモンストレーションする gherkin の例です。

```
    Given stateful service named "fabric:/MyApp/MyService" is created
    And a new replica is created as "Primary" with id "111"
    And a new replica is created as "IdleSecondary" with id "222"
    And a new replica is created as "IdleSecondary" with id "333"
    And all idle secondary replicas are promoted to active secondary
    When a request is made to add the an employee "John Smith"
    And the active secondary replica "222" is promoted to primary
    And a request is made to get all employees
    Then the request should should return the "John Smith" employee
```

このテストは、あるレプリカでキャプチャされたデータに対し、セカンダリ レプリカがプライマリに昇格した時点でアクセスできることをアサートするものです。 リライアブル コレクションが従業員データのバッキング ストアであると仮定すると、新しい従業員を保存するためのアプリケーション コードがトランザクションで `CommitAsync` を実行しなかった場合、このテストでエラーとして捕捉される可能性があります。 その場合、従業員を取得する 2 回目の要求時に、1 回目の要求によって追加された従業員は返されません。

### <a name="acting"></a>実行
#### <a name="mimic-service-fabric-replica-orchestration"></a>Service Fabric レプリカのオーケストレーションを模倣する
テストで複数のサービス インスタンスを管理するとき、これらのサービスの初期化と破棄の処理は、Service Fabric のオーケストレーションと同じ方法で行う必要があります。 たとえば Service Fabric は、新しいプライマリ レプリカでサービスを作成するときに、CreateServiceReplicaListener、OpenAsync、ChangeRoleAsync、RunAsync を呼び出します。 ライフサイクル イベントについては、次の記事をご覧ください。

- [ステートフル サービスのスタートアップ](service-fabric-reliable-services-lifecycle.md#stateful-service-startup)
- [ステートフル サービスのシャットダウン](service-fabric-reliable-services-lifecycle.md#stateful-service-shutdown)
- [ステートフル サービスのプライマリ スワップ](service-fabric-reliable-services-lifecycle.md#stateful-service-primary-swaps)

#### <a name="run-replica-role-changes"></a>レプリカのロール変更を実行する
単体テストでは、Service Fabric のオーケストレーションと同じ方法で、サービス インスタンスのロール変更を実行する必要があります。 ロールの状態機械については、次の記事をご覧ください。

[レプリカ ロールの状態機械](service-fabric-concepts-replica-lifecycle.md#replica-role)

ロール変更のシミュレーションは、テストにおける比較的重要な要素の 1 つであり、各レプリカの状態に矛盾がある問題を発見することができます。 レプリカの状態に矛盾が生じる原因としては、メモリ内の状態を静的変数またはクラス レベルのインスタンス変数に格納することが考えられます。 たとえば、キャンセル トークンや列挙型、構成オブジェクト、構成値が該当します。 また、RunAsync 時に与えられたキャンセル トークンがサービスに正しく伝わり、ロール変更が可能であることも、このシミュレーションで確認できます。 さらに、複数回 RunAsync を呼び出すことができないようにコードが記述されている場合に発生する問題も、ロール変更のシミュレーションで発見することができます。

#### <a name="cancel-cancellation-tokens"></a>キャンセル トークンのキャンセル処理を実行する
RunAsync に与えられたキャンセル トークンのキャンセル処理を行う単体テストを用意する必要があります。 これにより、サービスが正常にシャットダウンされることをテストで確認することができます。 長時間実行される処理や非同期処理は、このシャットダウン中に停止されなければなりません。 サービス上のプロセスの中で、長時間実行されるものとしては、たとえばリライアブル キューでメッセージをリッスンするプロセスが挙げられます。 このプロセスが、RunAsync 内やバックグラウンド スレッド内に直接存在することがあります。 実装には、このキャンセル トークンのキャンセル処理が発生した場合に、処理を終了するためのロジックが含まれている必要があります。

プライマリにしか存在すべきではないキャッシュやメモリ内の状態をステートフル サービスで利用している場合は、この時点で破棄する必要があります。 そのノードが後で再びプライマリになった場合に、この状態の一貫性を確保するためです。 その状態が適切に破棄されたことをキャンセル テストによって確認することができます。

#### <a name="execute-requests-against-multiple-replicas"></a>複数のレプリカに対して要求を実行する
アサート テストでは、複数の異なるレプリカに対して同じ要求を実行する必要があります。 ロール変更と組み合わせることで、一貫性の問題を発見することができます。 たとえば、テストで次のステップを実行できます。
1. 現在のプライマリに対する書き込み要求を実行します。
2. ステップ 1 で書き込まれたデータを取得する読み取り要求を現在のプライマリに対して実行します。
3. セカンダリをプライマリに昇格させます。 同時に、現在のプライマリはセカンダリに降格させる必要があります。
4. 新しいセカンダリに対して、ステップ 2 と同じ読み取り要求を実行します。

最後のステップで、返されるデータに一貫性がある、とアサート (表明) することができます。 サービスによって返されるデータがメモリ内にあるものの、実体はリライアブル コレクションにある、というような問題は、このテストで発見できる可能性があります。 そのようなメモリ内データは、リライアブル コレクションに存在するデータと適切に同期されていない可能性があります。

通常、メモリ内データは、リライアブル コレクションに存在するデータの集計やセカンダリ インデックスを作成する目的で使用します。

### <a name="asserting"></a>アサート
#### <a name="ensure-responses-match-across-replicas"></a>レプリカ間で応答を確実に一致させる
単体テストでは、特定の要求に対する応答が複数のレプリカ間で、プライマリへの切り替えが生じた後も一致していることをアサートする必要があります。 これにより、応答として返されたデータの実体がリライアブル コレクションではない、またはメモリ内に保持されているもののレプリカ間でデータを同期するメカニズムが欠落している、というような潜在的な問題を表面化させることができます。 Service Fabric によって再調整 (新しいプライマリ レプリカへのフェールオーバー) が行われた後も、サービスから確実に一貫した応答が返されます。

#### <a name="verify-service-respects-cancellation"></a>キャンセル要求がサービスに正しく伝わっていることを確認する
キャンセル トークンのキャンセル処理が発生したときに終了されるべき長時間実行プロセスや非同期プロセスが、キャンセル後に実際に終了されることを確認する必要があります。 これにより、ロール変更の対象となるレプリカに関係なく、プライマリ以外のレプリカで実行すべきでないプロセスは、切り替えの完了前に確実に停止されます。 また、そのようなプロセスによってロール変更が妨げられたり、Service Fabric からのシャットダウン要求がブロックされたりする問題の発見にもつながります。

#### <a name="verify-which-replicas-should-serve-requests"></a>どのレプリカが要求を処理すべきかを確認する
テストでは、プライマリ以外のレプリカに要求がルーティングされた場合に必要な動作をアサートする必要があります。 Service Fabric には、セカンダリ レプリカに要求を処理させる機能があります。 しかしリライアブル コレクションへの書き込みは、プライマリ レプリカからしか実行できません。 実際のアプリケーションの意図として、プライマリ レプリカだけが要求を処理する場合、またはセカンダリで処理できるのが要求の一部だけである場合には、肯定的なケースと否定的なケースの両方について、期待される動作をテストでアサートする必要があります。 ここでいう否定的なケースとは、要求を処理すべきではないレプリカに要求がルーティングされることを指し、肯定的なケースは、その逆を指します。

## <a name="next-steps"></a>次のステップ
[ステートフル サービスの単体テスト](service-fabric-how-to-unit-test-stateful-services.md)の方法を確認します。
