---
title: Azure Functions の geo ディザスター リカバリーと高可用性
description: Azure Functions で冗長性のために地理的リージョンを使用してフェールオーバーする方法。
ms.assetid: 9058fb2f-8a93-4036-a921-97a0772f503c
ms.topic: conceptual
ms.date: 08/27/2021
ms.openlocfilehash: 27730e2b6c1ed760f43a054901d16b58ca80acd9
ms.sourcegitcommit: f6e2ea5571e35b9ed3a79a22485eba4d20ae36cc
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/24/2021
ms.locfileid: "128645229"
---
# <a name="azure-functions-geo-disaster-recovery"></a>Azure Functions geo ディザスター リカバリー

Azure リージョンまたはデータセンター全体でダウンタイムが発生した場合でも、ミッション クリティカルなコードは別のリージョンで処理を続行する必要があります。 この記事では、ディザスター リカバリーを可能にする関数をデプロイするために使用できるいくつかの戦略について説明します。

## <a name="basic-concepts"></a>基本的な概念

Azure Functions は、特定のリージョン内の関数アプリで実行されます。 使用可能な組み込みの冗長性は存在しません。 停止中に実行が失われることを回避するために、同じ関数を複数のリージョン内の関数アプリに冗長にデプロイできます。  

同じ関数コードを複数のリージョンで実行する場合は、考慮すべきパターンとして次の 2 つがあります。

| Pattern | 説明 |
| --- | --- |
|**アクティブ/アクティブ** | 両方のリージョン内の関数が、重複した方法またはローテーションのどちらかで、アクティブに実行されイベントを処理しています。 アクティブ/アクティブのパターンは、HTTP によってトリガーされる重要な関数のための [Azure Front Door](../frontdoor/front-door-overview.md) と組み合わせて使用することをお勧めします。 |
|**アクティブ/パッシブ** | イベントを受信するリージョンでは関数がアクティブに実行されるのに対して、2 番目のリージョン内の同じ関数はアイドル状態のままになります。  フェールオーバーが必要になると、2 番目のリージョンがアクティブ化され、処理を引き継ぎます。 このパターンは、HTTP によってトリガーされないイベント ドリブン関数 (Service Bus やイベント ハブによってトリガーされる関数など) にお勧めします。

複数リージョン デプロイの詳細については、「[可用性の高い複数リージョンの Web アプリケーション](/azure/architecture/reference-architectures/app-service-web-app/multi-region)」のガイダンスを参照してください。

## <a name="redundancy-for-http-trigger-functions"></a>HTTP トリガー関数の冗長性

アクティブ/アクティブのパターンは、HTTP トリガー関数に最適なデプロイ モデルです。 この場合は、両方のリージョン間で要求を調整するために [Azure Front Door](../frontdoor/front-door-overview.md) を使用する必要があります。 Azure Front Door は、複数のリージョンで実行されている関数間で HTTP 要求をルーティングおよびラウンドロビンできます。また、各エンドポイントの正常性も定期的にチェックします。 あるリージョン内の関数が正常性チェックへの応答を停止すると、Azure Front Door はそれをローテーションから外し、残りの正常な関数にのみトラフィックを転送します。  

![Azure Front Door と関数のアーキテクチャ](media/functions-geo-dr/front-door.png)  

## <a name="redundancy-for-non-http-trigger-functions"></a>非 HTTP トリガー関数の冗長性

他のサービスからのイベントを消費する関数の冗長性には、関連するサービスのフェールオーバー パターンと連携する別のパターンが必要です。 

### <a name="activepassive-redundancy-for-non-http-trigger-functions"></a>非 HTTP トリガー関数のアクティブ/パッシブ冗長性

アクティブ/パッシブは、1 つの関数だけが各メッセージを処理する方法を提供しますが、障害が発生した場合にセカンダリ リージョンにフェールオーバーするメカニズムを提供します。 関数アプリは、パートナー サービスのフェールオーバー動作 ([Azure Service Bus の geo リカバリー](../service-bus-messaging/service-bus-geo-dr.md)や [Azure Event Hubs の geo リカバリー](../event-hubs/event-hubs-geo-dr.md)など) と連携します。 セカンダリ関数アプリは、接続先のフェールオーバー サービスが現在アクティブではないため、"_パッシブ_" と見なされます。そのため、この関数アプリは基本的に "_アイドル状態_" です。

Azure Event Hubs トリガーを使用したトポロジの例を考えてみます。 この場合、アクティブ/パッシブ パターンには次のコンポーネントが必要です。

* プライマリ リージョンとセカンダリ リージョンの両方にデプロイされた Azure Event Hubs。
* プライマリとセカンダリのイベント ハブをペアリングするために、[geo ディザスターが有効](../service-bus-messaging/service-bus-geo-dr.md)になります。 これにより、接続情報を変更することなくイベント ハブに接続し、プライマリからセカンダリに切り替えるために使用できる "_別名_" も作成されます。
* 関数アプリは、プライマリとセカンダリ (フェールオーバー) の両方のリージョンにデプロイされますが、セカンダリ リージョン内のアプリは、メッセージが送信されないため、基本的にアイドル状態です。
* 関数アプリは、対応するイベント ハブの "*直接の*" (別名ではない) 接続文字列でトリガーされます。 
* イベント ハブへの発行元は、別名の接続文字列に対して発行する必要があります。 

![アクティブ/パッシブ アーキテクチャの例](media/functions-geo-dr/active-passive.png)

フェールオーバーの前、共有された別名に送信する発行元は、プライマリ イベント ハブにルーティングされます。 プライマリ関数アプリは、プライマリ イベント ハブだけをリッスンします。 セカンダリ関数アプリはパッシブで、かつアイドル状態です。 フェールオーバーが開始されるとすぐに、共有された別名に送信する発行元は、セカンダリ イベント ハブにルーティングされます。 セカンダリ関数アプリがアクティブになり、自動的にトリガーを開始します。  セカンダリ リージョンへの効果的なフェールオーバーは、イベント ハブから完全に実行でき、それぞれのイベント ハブがアクティブになった場合にのみ関数がアクティブになります。

[Service Bus](../service-bus-messaging/service-bus-geo-dr.md) や [Event Hubs](../event-hubs/event-hubs-geo-dr.md) を使用したフェールオーバーに関する情報と考慮事項の詳細を参照してください。

### <a name="activeactive-redundancy-for-non-http-trigger-functions"></a>非 HTTP トリガー関数のアクティブ/アクティブ冗長性

HTTP によってトリガーされない関数でのアクティブ/アクティブ デプロイも引き続き実現できます。 ただし、2 つのアクティブなリージョンが互いに対話または調整する方法を検討する必要があります。 それぞれが同じ Service Bus キューでトリガーされる 2 つのリージョンに同じ関数アプリをデプロイすると、それらのアプリは、そのキューのデキューでの競合コンシューマーとして機能します。 つまり、各メッセージはどちらか 1 つのインスタンスによってのみ処理されますが、これは、1 つの Service Bus インスタンスに単一障害点が引き続き存在することも示しています。 

代わりに、2 つの Service Bus キューを、プライマリ リージョンに 1 つ、セカンダリ リージョンに 1 つデプロイすることもできます。 この場合は、それぞれが自身のリージョン内でアクティブな Service Bus キューを指している 2 つの関数アプリが存在することになります。 このトポロジでの課題は、キュー メッセージを 2 つのリージョン間でどのように分散するかという点です。  これは多くの場合、各発行元がメッセージを "*両方の*" リージョンに発行しようとするため、各メッセージが両方のアクティブな関数アプリによって処理されることを示しています。 これにより、目的のアクティブ/アクティブのパターンが作成されますが、同時に、コンピューティングの重複やデータがいつ、またはどのように統合されるかに関する他の課題も生じます。 これらの課題があるため、非 HTTPS トリガー関数にはアクティブ/パッシブ パターンを使用することをお勧めします。

## <a name="next-steps"></a>次のステップ

* [Azure Front Door の作成](../frontdoor/quickstart-create-front-door.md)
* [Event Hubs のフェールオーバーの考慮事項](../event-hubs/event-hubs-geo-dr.md#considerations)
