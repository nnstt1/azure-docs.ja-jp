---
title: 検索結果の操作方法
titleSuffix: Azure Cognitive Search
description: Azure Cognitive Search において、検索結果の構成と並べ替え、ドキュメント数の取得、および検索結果へのコンテンツ ナビゲーションの追加を行います。
manager: nitinme
author: HeidiSteen
ms.author: heidist
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 04/06/2021
ms.openlocfilehash: e810a5d3a94ad4e356d0b44a422b757b5710a781
ms.sourcegitcommit: 2d412ea97cad0a2f66c434794429ea80da9d65aa
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/14/2021
ms.locfileid: "122182277"
---
# <a name="how-to-work-with-search-results-in-azure-cognitive-search"></a>Azure Cognitive Search での検索結果の操作方法

この記事では、Azure Cognitive Search でクエリ応答を作成する方法について説明します。 応答の構造は、クエリ内のパラメーター、つまり REST API での[検索ドキュメント](/rest/api/searchservice/Search-Documents)または .NET SDK での [SearchResults クラス](/dotnet/api/azure.search.documents.models.searchresults-1)によって決定されます。 クエリにパラメーターを使うことで、次のような方法で結果セットの構造を指定できます。

+ 結果に含めるドキュメント数を制限またはグループ化する (既定では 50 件)
+ 結果に含めるフィールドを選択する
+ 結果を並べ替える
+ 検索結果の本文内で一致する用語全体または一部を強調表示する

## <a name="result-composition"></a>結果の構成

検索ドキュメントは多数のフィールドで構成される可能性がありますが、一般に、結果セット内の各ドキュメントを表すために必要なものは数個しかありません。 クエリ要求で、応答にどのフィールドを表示するかを指定するには `$select=<field list>` を追加します。 あるフィールドを結果に含めるには、そのフィールドのインデックスに **取得可能** の属性が付けられている必要があります。 

最適に機能するフィールドには、各ドキュメントを比較対照して区別することにより、ユーザーの側にクリックスルー応答を誘うための十分な情報を提供するフィールドが含まれます。 eコマース サイトでは、それは製品名、説明、ブランド、色、サイズ、価格、評価などである場合があります。 hotels-sample-index という組み込みのサンプルの場合、それは次の例のフィールドのようになります。

```http
POST /indexes/hotels-sample-index/docs/search?api-version=2020-06-30 
    {  
      "search": "sandy beaches",
      "select": "HotelId, HotelName, Description, Rating, Address/City"
      "count": true
    }
```

> [!NOTE]
> 結果に画像ファイル (製品の写真やロゴなど) を含める場合、それらは Azure Cognitive Search の外部に格納しますが、画像の URL を参照するためのインデックス内のフィールドを検索ドキュメントに含めます。 結果内の画像をサポートするサンプル インデックスには、この [クイックスタート](search-create-app-portal.md)で紹介されている **realestate-sample-us** のデモや、[ニューヨーク市のジョブ デモ アプリ](https://aka.ms/azjobsdemo)が含まれます。

### <a name="tips-for-unexpected-results"></a>予期しない結果が生じた場合のヒント

結果の実質 (構造ではなく実質的な中身) が、予期しない内容になっている場合も少なくありません。 クエリの結果が予期しないものである場合は、こちらのクエリ変更を試して、結果が改善されるかどうかを確認できます。

+ **`searchMode=any`** (既定) を **`searchMode=all`** に変更し、いずれかの条件への一致ではなく、すべての条件への一致を強制します。 これは特に、ブール演算子がクエリに含まれているときに当てはまります。

+ さまざまな字句アナライザーやカスタム アナライザーを試して、クエリ結果が変わるかどうかを確認します。 既定のアナライザーは、ハイフンでつながれた単語を分割し、単語を原形に変換します。通常はこれにより、クエリ応答の堅牢性が向上します。 ただし、ハイフンを保持する必要がある場合、または文字列に特殊文字が含まれている場合は、インデックスに適切な形式のトークンが含まれるようにカスタム アナライザーを構成することが必要になる場合があります。 詳細については、「[部分的な用語検索と特殊文字を含むパターン (ハイフン、ワイルドカード、正規表現、パターン)](search-query-partial-matching.md)」を参照してください。

## <a name="paging-results"></a>ページングの結果

既定では、検索エンジンは最初の 50 個の一致まで返します。順序は、クエリがフルテキスト検索である場合は検索スコアによって決定され、完全一致のクエリの場合は任意の順序で返されます。

別の数の一致するドキュメントを返すには、クエリ要求に `$top` および `$skip` パラメーターを追加します。 このロジックを説明する一覧を次に示します。

+ インデックス内の一致するドキュメントの合計数を取得するには、`$count=true` を追加します。

+ 15 個の一致するドキュメントの最初のセットに加え、合計の一致の数を返します: `GET /indexes/<INDEX-NAME>/docs?search=<QUERY STRING>&$top=15&$skip=0&$count=true`

+ 2 番目のセットを返し、次の 15 個を取得するために最初の 15 個をスキップします: `$top=15&$skip=15`。 15 個の 3 番目のセットについて同じことを行います: `$top=15&$skip=30`

基になるインデックスが変更されている場合、ページ分割されたクエリの結果の安定性は保証されません。 ページングによって各ページの `$skip` の値が変更されますが、各クエリは独立しており、クエリ時にインデックス内に存在する (つまり、汎用データベースで見られるような結果のキャッシュやスナップショットは存在しない) ため、データの現在のビューに対して動作します。
 
次の例は、重複がどのように発生するかを示しています。 4 つのドキュメントを含む次のインデックスがあるとします。

```text
{ "id": "1", "rating": 5 }
{ "id": "2", "rating": 3 }
{ "id": "3", "rating": 2 }
{ "id": "4", "rating": 1 }
```
 
ここでは、結果を一度に 2 つ、評価の順序で返してもらいたいとします。 結果の最初のページを取得するために `$top=2&$skip=0&$orderby=rating desc` というクエリを実行すると、次の結果が生成されます。

```text
{ "id": "1", "rating": 5 }
{ "id": "2", "rating": 3 }
```
 
このサービスでは、クエリ呼び出しの間に `{ "id": "5", "rating": 4 }` という 5 番目のドキュメントがインデックスに追加されたとします。  その後すぐに、2 ページ目をフェッチするために `$top=2&$skip=2&$orderby=rating desc` というクエリを実行すると、次の結果が得られます。

```text
{ "id": "2", "rating": 3 }
{ "id": "3", "rating": 2 }
```
 
ドキュメント 2 が 2 回フェッチされることに注意してください。 これは、新しいドキュメント 5 の方が評価の値が大きいため、ドキュメント 2 の前に並べ替えられ、最初のページに割り当てられるためです。 この動作は予期されない可能性がありますが、検索エンジンの動作としては一般的なものです。

## <a name="ordering-results"></a>結果の並べ替え

フルテキスト検索クエリの場合、結果は、([TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf) から導出された) ドキュメント内の用語頻度と近接性に基づいて計算された検索スコアによって自動的にランク付けされます。ここで、検索用語に対するより多くの、またはより強力な一致を含むドキュメントにより高いスコアが割り当てられます。 

検索スコアは、一般的な意味での関連性を示すものであり、同じ結果セット内の他のドキュメントと比べた場合の一致の強さが反映されています。 ただし、スコアは、あるクエリと次のものとの間で必ずしも一貫しているとは限らないため、クエリを操作していると、検索ドキュメントの順序付け方法における小さな不一致に気付くことがあります。 これが発生する理由については、次のいくつかの説明があります。

| 原因 | 説明 |
|-----------|-------------|
| データのボラティリティ | ドキュメントを追加、変更、または削除すると、インデックス コンテンツは変動します。 インデックスの更新が徐々に処理されるに従って用語頻度は変化し、一致するドキュメントの検索スコアに影響を与えます。 |
| 複数のレプリカ | 複数のレプリカを使用するサービスの場合、クエリは、各レプリカに対して並列に発行されます。 検索スコアを計算するために使用されるインデックス統計はレプリカごとに計算され、クエリ応答の中で結果がマージされ、順序付けられます。 レプリカのほとんどは互いのミラーですが、状態の小さな違いのために統計は異なる場合があります。 たとえば、あるレプリカで、他のレプリカからマージされた、その統計に寄与しているドキュメントが削除されることがあります。 通常、レプリカごとの統計の違いは、小さなインデックスの方がより顕著です。 |
| 同一のスコア | 複数のドキュメントのスコアが同じである場合、それらはいずれも最初に表示される可能性があります。  |

### <a name="how-to-get-consistent-ordering"></a>一貫した順序付けを実現する方法

一貫した順序付けがアプリケーションの要件である場合は、フィールドに対して [ **`$orderby`** 式](query-odata-filter-orderby-syntax.md)を明示的に定義できます。 結果の順序付けに使用できるのは、 **`sortable`** としてインデックスが付けられたフィールドだけです。 **`orderby`** パラメーターの値を指定して、フィールド名と、地理空間の値に対する [ **`geo.distance()` 関数**](query-odata-filter-orderby-syntax.md)の呼び出しを含める場合、 **`$orderby`** で一般的に使用されるフィールドには評価、日付、および場所のフィールドがあります。

一貫性を高める別の方法として、[カスタム スコアリング プロファイル](index-add-scoring-profiles.md)を使用する方法があります。 スコアリング プロファイルを使用すると、検索結果内の項目のランク付けをより細かく制御できるため、特定のフィールドで見つかる一致を向上させることができます。 追加のスコアリング ロジックにより、各ドキュメントの検索スコアがさらに離れるため、レプリカ間のわずかな違いのオーバーライドに役立ちます。 このアプローチには[ランク付けアルゴリズム](index-ranking-similarity.md)をお勧めします。

## <a name="hit-highlighting"></a>検索結果の強調表示

検索結果の強調表示とは、結果内の一致する用語に適用され、一致が容易に見つかるようにするテキストの書式設定 (太字や黄色の強調表示など) を指します。 検索結果の強調表示の手順については、[クエリ要求](/rest/api/searchservice/search-documents)に関する記事で説明しています。 

ヒットの強調表示を有効にするには、`highlight=[comma-delimited list of string fields]` を追加して、強調表示を使用するフィールドを指定します。 強調表示は、説明フィールドなど、一致が一目ではわかりにくい、長いコンテンツ フィールドに対して便利です。 **検索可能** として属性付けされたフィールド定義だけが、ヒットの強調表示に使用できます。

既定では、Azure Cognitive Search によって、フィールドごとに最大 5 つの強調表示が返されます。 この数値を調整するには、フィールドに、ダッシュに続く整数を追加します。 たとえば、`highlight=Description-10` とすると、[説明] フィールドの一致するコンテンツに対して最大 10 個の強調表示が返されます。

書式設定は、語句全体のクエリに適用されます。 書式設定の種類は、タグ `highlightPreTag` および `highlightPostTag` によって決定され、コードでは応答を処理します (たとえば、太字のフォントや黄色の背景を適用するなど)。

次の例では、[説明] フィールド内で見つかった用語 "sandy"、"sand"、"beaches"、"beach" に強調表示のタグが付けられます。 エンジンのクエリ拡張をトリガーするクエリ (あいまい検索やワイルドカード検索など) では、検索結果の強調表示のサポートが制限されています。

```http
GET /indexes/hotels-sample-index/docs/search=sandy beaches&highlight=Description?api-version=2020-06-30 
```

```http
POST /indexes/hotels-sample-index/docs/search?api-version=2020-06-30 
    {  
      "search": "sandy beaches",  
      "highlight": "Description"
    }
```

### <a name="new-behavior-starting-july-15"></a>新しい動作 (7 月15日以降)

2020 年 7 月 15 日以降に作成されたサービスでは、異なる強調表示エクスペリエンスが提供されます。 この日付より前に作成されたサービスについては、強調表示の動作に変更はありません。 

新しい動作では:

+ フル フレーズのクエリに一致する語句だけが返されるようになります。 クエリ フレーズ "super bowl" では、次のような強調表示が返されます。

  ```json
  "@search.highlights": {
      "sentence": [
          "The <em>super</em> <em>bowl</em> is super awesome with a bowl of chips"
     ]
  ```

  *super* および *bowl* という他のインスタンスは、フレーズ全体に一致しないため、強調表示されません。

ヒットの強調表示を実装するクライアント コードを記述する場合は、この変更点に注意してください。 まったく新しい検索サービスを作成しない限り、この変更の影響を受けることはありません。

## <a name="next-steps"></a>次のステップ

クライアントの検索ページをすばやく生成するには、次のオプションを検討してください。

+ [アプリケーション ジェネレーター](search-create-app-portal.md)。ポータルで、検索バー、ファセット ナビゲーション、画像を含む結果領域を備えた HTML ページを作成します。
+ [C# での最初のアプリの作成](tutorial-csharp-create-first-app.md)に関するページは、機能するクライアントを構築するチュートリアルです。 サンプル コードは、ページ分割されたクエリ、検索結果の強調表示、並べ替えを示しています。

複数のコード サンプルに Web フロントエンド インターフェイスが含まれており、[ニューヨーク市のジョブ デモ アプリ](https://aka.ms/azjobsdemo)または[ライブ デモ サイトを使用した JavaScript サンプル コード](https://github.com/liamca/azure-search-javascript-samples)でも見つけることができます。
